[TOC]

# 1. 时间复杂度和空间复杂度

## 1.1. 时间复杂度

> 时间复杂度是什么?

简单来说"时间复杂度"就是一个函数,用大`O`(字母瓯)来表示,例如:

```javascript
O(1)
O(n)
O(logN)
...
```

通过`时间复杂度`来定性描述该算法的运行时间,注意它只是一个`定性`的描述,也就是说是一个`估时`,因为程序没有执行的时候真实的执行时间是无法预知的.只能预估它的一个时间复杂度来判断这个算法的优劣!

### 1.1.1. 时间复杂度图示

> 看下面的一个图示,下图可以形象的表示几个重点的时间复杂度的趋势

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gix9m7zeigj30n20lvn3i.jpg)

**需要重点关注的几个时间复杂度的指标:**

-   `1` - 紫色
-   `O(log2N)` - 蓝色(以`2`为底的`logN`)
-   `O(n)` - 绿色
-   `n²` - 红色

### 1.1.2. 时间复杂度简单代码示例:

**O(1)**

```javascript
let i = 0;
i += 1;
```

这段代码只会执行一次,它的时间复杂度就为`1`

**O(n)**

```javascript
// 时间复杂度为O(n)的一段代码
for (let i = 0; i < n; i++) {
    console.log(n);
}
```

上述这段代码会循环`n`次,那么它的时间复杂度就为`O(n)`

> 思考题:如果时间复杂度为`O(1)`的和时间复杂度为`O(n)`的相加,那么他们的时间复杂度为多少?

```javascript
// 将上面的代码进行组合,实现O(1)+O(n)的时间复杂度
let i = 0;
i += 1;
for (let i = 0; i < n; i++) {
    console.log(n);
}
```

解答:其实上面的代码的时间复杂度是`O(n)`,因为在增长趋势中`O(n)`的增长趋势远远大于`O(1)`的时间复杂度,所以他们相加的时间复杂度也是`O()n`

**O(n) \* O(n) = O(n²)**

```javascript
// 看一个时间复杂度为 O(n²) 的例子
for(let i = 0;i<n;i++>){
    for(let j = 0;j<n;j++){
        console.log(i,j)
    }
}
```

**O(logN)**

```javascript
// 时间复杂度为 O(logN) 的例子
let i = 1;
while (i < n) {
    console.log(i);
    i *= 2;
}
```

> 这里留一个疑问,什么是`log`,有点忘记了!

## 1.2. 空间复杂度

### 1.2.1. 空间复杂度是什么?

-   和时间复杂度一样,空间复杂度也是用一个函数来表示的,也是用大`O`来表示.例如:`O(1)`,`O(n)`,`O(n²)`
-   算法在运行过程中临时占用存储空间大小的量度(说白了就是你写的代码在运行的时候占用的内存多不多,当然占用的越少越好!)

### 1.2.2. 空间复杂度的例子

**O(1)**

> 只声明了一个变量,那么它的空间复杂度就恒定唯一

```javascript
let i = 0;
i += 1;
```

**O(n)**

> 声明了一个数组,在不停的给数组中添加数据,添加 n 个数据,那么它就会在内存中开辟 n 个内存单元,这样它的空间复杂度就为 O(n)

```javascript
let list = [];
for (let i = 0; i < n; i++) {
    list.push(i);
}
```

**O(n²)**

> 空间复杂度为 O(n²)其实就是一个`矩阵`

```javascript
let matrix = [];
for (let i = 0; i < n; i++) {
    matrix.push([]);
    for (let j = 0; j < n; j++) {
        matrix[i].push(j);
    }
}
// 执行上述代码,给 n 赋值为10,执行结果如下所示:
matrix = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
];
```

上面的执行结果就是所谓的`矩阵`(类似于前端布局中的 `grid` 布局)

## 1.3. 相关资料

[百度百科-时间复杂度](https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E6%80%A7/5930669?fromtitle=%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&fromid=1894057&fr=aladdin)
[百度百度-空间复杂度](https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
[一文看懂时间复杂度和空间复杂度](https://zhuanlan.zhihu.com/p/50479555)
[一套图 搞懂“时间复杂度”](https://blog.csdn.net/qq_41523096/article/details/82142747)
